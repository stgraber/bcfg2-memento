#!/usr/bin/python
# This file is managed by Bcfg2. Any local change will be lost.

import apt_pkg, apt, pynag

# Packages that can't be installed any other way
whitelist=[
    'zimbra-apache',
    'zimbra-convertd',
    'zimbra-core',
    'zimbra-ldap',
    'zimbra-logger',
    'zimbra-mta',
    'zimbra-snmp',
    'zimbra-spell',
    'zimbra-store',
]

apt_pkg.init_config()
apt_pkg.init_system()
cache = apt_pkg.Cache(apt.progress.base.OpProgress())

def check_dpkg(options, args):
    broken_packages=[]
    unknown_packages=[]

    for pkg in cache.packages:
        # We don't care for non-installed packages
        if pkg.current_state != apt_pkg.CURSTATE_NOT_INSTALLED:
            # Check for broken packages (weird status)
            if pkg.current_state != apt_pkg.CURSTATE_INSTALLED:
                broken_packages.append(pkg.name)
                continue

            # Check for broken packages (no version)
            if len(pkg.version_list) == 0 or not pkg.current_ver:
                broken_packages.append(pkg.name)
                continue

            if pkg.Name in whitelist:
                continue

            # Check if current package is downloadable
            if not pkg.current_ver.downloadable:
                upgrade=False
                # If not, iterate through all versions
                # check if there's an higher version that's downloadable
                for version in pkg.version_list:
                    if version.downloadable:
                        if apt_pkg.version_compare(version.ver_str,pkg.current_ver.ver_str) >= 0:
                            upgrade=True
                            break

                # If not, we don't have an install source
                if not upgrade:
                    unknown_packages.append(pkg.name)
                    continue

    if options.verbose:
        string = "%s unknown packages (%s) and %s broken packages (%s)" % (len(unknown_packages), ', '.join(unknown_packages), len(broken_packages), ', '.join(broken_packages))
    else:
        string = "%s unknown packages and %s broken packages" % (len(unknown_packages), len(broken_packages))

    if len(broken_packages) > 0 or len(unknown_packages) > 0:
        raise pynag.ExecutionCritical(string)
    else:
        return string

check_dpkg = pynag.Check(
    func=check_dpkg,
    name="DPKG",
    timeout=60
)
check_dpkg.run()
