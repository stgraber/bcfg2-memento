#!/usr/bin/python
# This file is managed by Bcfg2. Any local change will be lost.

#
# Authors: Simon Deziel <sdeziel@revolutionlinux.com>
#          Gabriel Filon <gabriel.filion@revolutionlinux.com>
#
# Inspired by unattended-upgrade by:
# (c) 2005-2008 Canonical
# Author: Michael Vogt <michael.vogt@ubuntu.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from os import getuid, path, makedirs
from string import strip, split
from warnings import filterwarnings
filterwarnings("ignore", "apt API not stable yet", FutureWarning)
import sqlite3
import datetime
import apt_pkg
from apt_inst import debExtractControl
from apt import Cache

try:
    import pynag as nagios
except ImportError:
    import sys
    print "UNKNOWN: Cannot use the Nagios plugins library"
    sys.exit(3)


class MyCache(Cache):
    def clear(self):
        """Clear all marked packages.

        This is only necessary for python-apt < 0.7.9
        """
        self._depcache.Init()
        assert (self._depcache.InstCount == 0 and
                self._depcache.BrokenCount == 0 and
                self._depcache.DelCount == 0)


def is_allowed_origin(pkg, allowed_origins):
    """Return True if one of pkg's origins is allowed, False otherwise."""

    if not pkg.candidateOrigin:
        return False
    for origin in pkg.candidateOrigin:
        for allowed in allowed_origins:
            if origin.origin == allowed[0] and origin.archive == allowed[1]:
                return True
    return False


def check_cache_sanity(cache, allowed_origins, blacklist):
    """Return True if current cache state is sane, false otherwise.

    A non-sane state means that either:
        packages are broken
        packages are marked for deletion
        packages from unallowed origins are marked for install or upgrade
        blacklisted packages are marked for install or upgrade
    """

    if cache._depcache.BrokenCount != 0:
        return False
    for pkg in cache:
        if pkg.markedDelete:
            return False
        if pkg.markedInstall or pkg.markedUpgrade:
            if not is_allowed_origin(pkg, allowed_origins):
                return False
            if pkg.name in blacklist:
                return False
    return True


_pkgnames_cache = {}
def pkgname_from_deb(debfile):
    """Extract the package name from 'debfile'.

    Names are cached to avoid reopening the debfile each time its name is
    requested.
    """
    if _pkgnames_cache.has_key(debfile):
        return _pkgnames_cache[debfile]
    control = debExtractControl(open(debfile))
    sections = apt_pkg.ParseSection(control)
    _pkgnames_cache[debfile] = sections["Package"]
    return _pkgnames_cache[debfile]


def conffiles_differ(debfile):
    """Return True if config file hashes differ between filesystem and package."""
    pkgname = pkgname_from_deb(debfile)
    status_file = apt_pkg.Config.Find("Dir::State::status")
    parse = apt_pkg.ParseTagFile(open(status_file,"r"))
    while parse.Step():
        if parse.Section.get("Package") == pkgname and parse.Section.has_key("Conffiles"):
            conffiles = parse.Section.get("Conffiles")
            # Conffiles:
            # /etc/bash_completion.d/m-a c7780fab6b14d75ca54e11e992a6c11c
            for line in conffiles.splitlines():
                l = split(strip(line))
                assert(len(l) >=2)
                file = l[0]
                md5 = l[1]
                if len(l) > 2:
                    obs = l[2]
                else:
                    obs = None
                if path.exists(file) and obs != "obsolete":
                    current_md5 = apt_pkg.md5sum(open(file).read())
                    if current_md5 != md5:
                        return True
    return False


def dpkg_conffile_prompt():
    """Return True if dpkg will prompt the user about conflicts."""
    options = apt_pkg.Config.ValueList("DPkg::Options")
    if not options:
        return True

    for option in map(strip, options):
        if option in ["--force-confold", "--force-confnew"]:
            return False
    return True


def upgradable_pkgs(cache, allowed_origins, opt, db):
    """Generate a list of packages that we should upgrade now.

    For difference in running time with the "apt-get upgrade" command that is
    run via cron, we need to wait some time before considering a package as
    needing to be upgraded.
    """
    now = datetime.datetime.now()
    yesterday = now - datetime.timedelta(hours=opt.upgrade_delay)

    c = db.execute("select name,version from upgrades where date < datetime(?)", (yesterday,))
    ready_queue = dict(c.fetchall())
    nagios.nagios_debug("ready queue: %s", ready_queue)
    c = db.execute("select name,version from upgrades where date > datetime(?)", (yesterday,))
    wait_queue = dict(c.fetchall())
    nagios.nagios_debug("wait queue: %s", wait_queue)

    db_modified = False
    for pkg in cache:
        is_ready = ready_queue.get(pkg.name)
        is_awaiting = wait_queue.get(pkg.name)
        version = is_ready or is_awaiting
        upgradable = pkg.isUpgradable and is_allowed_origin(pkg, allowed_origins)

        if version and not upgradable:
            nagios.nagios_debug("package %s is not upgradable anymore, removing it from database.", pkg.name)
            db.execute("delete from upgrades where name=?", (pkg.name, ))
            db_modified = True
        elif upgradable:
            if version and version < pkg.candidateVersion:
                nagios.nagios_debug("newer version (%s) found for package %s. reinserting in wait queue", pkg.candidateVersion, pkg.name)
                db.execute("update upgrades set version=?,date=datetime(?) where name=?", (pkg.candidateVersion, now, pkg.name))
                db_modified = True
            elif is_ready:
                yield pkg
            elif not is_awaiting:
                nagios.nagios_debug("new package %s awaiting upgrade, adding it to wait queue.", pkg.name)
                db.execute("insert into upgrades values (?,?,datetime(?))",
                           (pkg.name, pkg.candidateVersion, now))
                db_modified = True

    if db_modified:
        nagios.nagios_debug("all modifications to wait queue are now effective.")
        db.commit()

def check_unattended_upgrade(opt, db):
    """Upgrade packages that are safe and warn of any undesired state.

    Using an apt.Cache, find out what packages needs to be upgraded. Exclude
    anything that doesn't have an allowed origin or that will get the
    installation into an un-sane state. Download relevant packages and install
    them. If any downloaded package has configuration files conflicts, don't
    install them and add them to the "untreated" packages list.

    Any remaining untreated package is considered as requiring manual
    attention. Count of untreated packages is compared to the check thresholds
    to set the check's state.
    """
    cache = MyCache()
    if cache._depcache.BrokenCount > 0:
        raise nagios.ExecutionCritical("Some packages are broken and need manual fixing")

    # format (origin, archive), e.g. ("Ubuntu","dapper-security")
    allowed_origins = map(
        split,
        apt_pkg.Config.ValueList("Unattended-Upgrade::Allowed-Origins")
    )
    nagios.nagios_debug("allowed origins: %s", allowed_origins)
    if not allowed_origins:
        # Since there's no allowed origin, nothing will be considered. stop
        # work here.
        return "0 package(s) need attention"

    blacklist = apt_pkg.Config.ValueList("Unattended-Upgrade::Package-Blacklist")
    nagios.nagios_debug("blacklisted packages from config: %s", blacklist)

    pkgs_to_upgrade = []
    for pkg in upgradable_pkgs(cache, allowed_origins, opt, db):
        try:
            pkg.markUpgrade()  # probably the candidate for raising SystemError
            if check_cache_sanity(cache, allowed_origins, blacklist):
                # change doesn't seem to break anything
                print "marking package %s for upgrade", pkg.name
                pkgs_to_upgrade.append(pkg)
        except SystemError:
            # can't upgrade
            pass
        else:
            # clear all superfluous states and mark the packages with sane
            # changes so that we see if other packages will conflict with our
            # choice of upgrade.
            cache.clear()
            for pkg2 in pkgs_to_upgrade:
                pkg2.markUpgrade()

    fetcher = apt_pkg.GetAcquire()
    slist = apt_pkg.GetPkgSourceList()
    slist.ReadMainList()
    pm = apt_pkg.GetPackageManager(cache._depcache)
    try:
        pm.GetArchives(fetcher,slist,cache._records)
    except SystemError, e:
        raise nagios.ExecutionUnknown("GetArchives() failed: %s" % e)
    print "downloading packages."
    fetcher.Run()  # download requested packages

    if dpkg_conffile_prompt():
        # conflict resolution will be asked on the terminal. blacklist any
        # package with conflicts
        for item in fetcher.Items:
            if item.Status == item.StatError:
                raise nagios.ExecutionUnknown("An error ocured: %s" % item.ErrorText)
            if not item.Complete:
                raise nagios.ExecutionUnknown("failed to download the package %s" % pkgname_from_deb(item.DestFile))
            if not item.IsTrusted or conffiles_differ(item.DestFile):
                print "package %s has config files with conflicts, blacklisting it." % pkgname_from_deb(item.DestFile)
                blacklist.append(pkgname_from_deb(item.DestFile))

    # Packages to upgrade count
    num_unhandled = len(blacklist)
    if num_unhandled > 0:
        print "Packages that require attention: %s" % blacklist

        if num_unhandled >= opt.critical_threshold:
            raise nagios.ExecutionCritical("%d package(s) need attention" % num_unhandled)
        elif num_unhandled >= opt.warn_threshold:
            raise nagios.ExecutionWarning("%d package(s) need attention" % num_unhandled)

    return "%d package(s) need attention" % num_unhandled

def init_and_run(options, args):
    """Verify execution context and initialize database, then run."""
    if getuid() != 0:
        raise nagios.ExecutionUnknown(
            "root privileges are required to run that check"
        )

    opt = options

    if not path.exists(path.dirname(opt.db_file)):
        makedirs(path.dirname(opt.db_file))
    create_db = not path.exists(opt.db_file)
    try:
        db = sqlite3.connect(opt.db_file)
    except sqlite3.OperationalError, e:
        raise nagios.ExecutionUnknown("%s" % e)
    if create_db:
        nagios.nagios_debug("database uninitialized. creating table 'upgrades'.")
        db.execute("create table upgrades(name,version,date)")

    return check_unattended_upgrade(options, db)


if __name__ == "__main__":
    check_unattended = nagios.Check(
        func=init_and_run,
        name="UNATTENDED-UPGRADE",
        timeout=60
    )

    check_unattended.add_option(
        "-w", "--warning", type="int", default=1,
        dest="warn_threshold", metavar="WARN",
        help="Define the warning threshold in package number."
    )
    check_unattended.add_option(
        "-c", "--critical", type="int", default=3,
        dest="critical_threshold", metavar="CRITICAL",
        help="Define the critical threshold in package number."
    )
    check_unattended.add_option(
        "--upgrade-delay", type="int", default=24, dest="upgrade_delay",
        help="Number of hours to wait before upgrading packages."
    )
    check_unattended.add_option(
        "--db-file", dest="db_file",
        default="/var/cache/check_unattended-upgrade/upgrades.sqlite",
        help="SQLite3 database file in which upgrades are stored."
    )

    check_unattended.run()
